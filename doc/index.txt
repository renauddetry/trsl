// (C) Copyright Renaud Detry   2007.
// Distributed under the Boost Software License, Version 1.0. (See
// accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

/** @mainpage
 *
 * TRSL is a C++ library that implements several sampling schemes
 * behind an (STL-like) iterator interface. The library may be used
 * e.g. in particle filtering or probabilistic inference frameworks.
 *
 * @section index_license License
 *
 * TRSL is distributed under the <a
 * href="http://www.boost.org/LICENSE_1_0.txt" >Boost Software
 * License</a> (BSL). BSL is a GPL-compatible <a
 * href="http://www.fsf.org/licensing/licenses" >free software
 * license</a>, very similar to the BSD license and the MIT license;
 * see <a href="http://www.boost.org/more/license_info.html" >Boost
 * Software License Background</a>. BSL is currently being reviewed
 * for OSI approval, see the end of <a
 * href="http://groups.google.com/group/comp.lang.c++.moderated/browse_thread/thread/1963de1fba1e9cf8/643e5618c0f7574e"
 * >this thread</a>, and <a href="https://osi.osuosl.org/ticket/45"
 * >this ticket</a>.
 *
 * @section index_services Source
 *
 * TRSL is in a usable state. However, as its version number suggests,
 * it is likely to grow and change interface in the future.
 *
 * <dl>
 *
 * <dt><b>Downloads</b></dt>
 *
 * <dd>Releases are available at the Sourceforge <a
 * href="http://sourceforge.net/project/showfiles.php?group_id=212585&package_id=255741&release_id=561630"
 * >download page</a>. The latest sources are available through
 * Subversion:<br><tt>svn co
 * https://trsl.svn.sourceforge.net/svnroot/trsl/trunk trsl</tt></dd>
 *
 * <dt><b>Project Services</b></dt>
 *
 * <dd>Sourceforge <a href="http://sourceforge.net/projects/trsl"
 * >project page</a>.</dd>
 *
 * </dl>
 *
 * TRSL is meant to be OS Portable (Source code to work with many OS
 * platforms). However, I could only test it with GCC (under Linux and
 * under MacOS X). If anyone tries it with a different compiler, <a
 * href="http://sourceforge.net/forum/?group_id=212585" >please
 * comment</a>!
 *
 * The source documentation is currently quite thin. Then again, me
 * being the only know user so far, I haven't felt the thrill to write
 * more :-). If there's anyone out there using TRSL, <a href="http://sourceforge.net/forum/?group_id=212585" >please let me
 * know</a>!
 *
 * @section index_feedback Feedback
 *
 * The preferred mean of communication is currently the Sourceforge <a
 * href="http://sourceforge.net/forum/?group_id=212585" >forums</a>
 * (anonymous posts allowed).
 *
 * @section index_products Products
 *
 * The central TRSL product is trsl::is_picked_systematic, a predicate
 * functor to use in combination with trsl::persistent_filter_iterator
 * to form a <em>sample iterator</em>.  The sample iterator accesses a
 * population of elements through a range defined by a pair of Forward
 * Iterators (begin/end), and provides on-the-fly iteration through a
 * sample of the population.
 *
 * Let us assume a particle filter implementation, in which we find a
 * population of particles (<tt>struct Particle { weight; x; y;
 * }</tt>) in a container <tt>ParticleCollection</tt>. The following
 * bit of code shows an example of how to iterate through a sample of
 * the population after having implemented
 * <tt>ParticleCollection::sample_begin(size_t)</tt> and
 * <tt>ParticleCollection::sample_end()</tt> using
 * e.g. trsl::is_picked_systematic.
 *
@code
const size_t POPULATION_SIZE = 100;
const size_t SAMPLE_SIZE = 10;

//-----------------------//
// Generate a population //
//-----------------------//

ParticleCollection population;
for (size_t i = 0; i < POPULATION_SIZE; ++i)
{
  Particle p(double(rand())/RAND_MAX,  // weight
             double(rand())/RAND_MAX,  // position (x)
             double(rand())/RAND_MAX); // position (y)
  population.add(p);
}

//----------------------------//
// Sample from the population //
//----------------------------//

ParticleCollection sample;

//-- population contains 100 elements. --//

for (ParticleCollection::const_sample_iterator
       si = population.sample_begin(SAMPLE_SIZE),
       se = population.sample_end();
     si != se; ++si)
{
  Particle p = *si;
  p.setWeight(1);
  sample.add(p);

  // ... or do something else with *si ...
}

//-- sample contains 10 elements. --//

assert(sample.size() == SAMPLE_SIZE);
@endcode
 *
 * The second TRSL product is trsl::random_permutation_iterator, which
 * provides an iterator over a random permutation of a range.
 *
 * @section index_author Authors
 *
 * TRSL is written by <a href="http://sourceforge.net/users/renauddetry/"
 * >Renaud Detry</a>.
 *
 * TRSL is based on the excellent <a
 * href="http://www.boost.org/libs/iterator/doc/index.html" >Boost
 * Iterators Library</a>.
 *
 */
